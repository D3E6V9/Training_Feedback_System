from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, FileResponse, JsonResponse
from django.core.paginator import Paginator
from django.utils import timezone
from django.template.loader import render_to_string
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth import login
from django.conf import settings
from django.views.decorators.csrf import ensure_csrf_cookie, csrf_protect
from .models import TrainingSession, FeedbackResponse, Trainer, FeedbackReport
from .forms import FeedbackForm, TrainerForm, TrainingSessionForm, FeedbackImageUploadForm
from .utils import FeedbackAnalyzer
from .rating_detector import AdvancedRatingDetector
import qrcode
import pytesseract
import cv2
import numpy as np
import pandas as pd
import json
import os
import tempfile
import shutil
import base64
from io import BytesIO
from PIL import Image
from rapidfuzz import fuzz, process
import traceback

# Use system PATH for Tesseract (since tesseract is installed and available)
tesseract_path = shutil.which('tesseract')
if tesseract_path:
    pytesseract.pytesseract.tesseract_cmd = tesseract_path
else:
    # Set the full path to tesseract.exe for Windows (update this path if your tesseract.exe is elsewhere)
    pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'

@csrf_protect
def public_session_list(request):
    """
    Display a list of active training sessions for public feedback submission.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page with the list of sessions.
    """
    sessions = TrainingSession.objects.filter(
        is_active=True,
        date__gte=timezone.now().date()
    ).select_related('trainer')
    return render(request, 'feedback/public_session_list.html', {'sessions': sessions})

@csrf_protect
def submit_feedback(request, session_id):
    """
    Allow public users to submit feedback for a specific training session.

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered HTML page for feedback form or redirect on success.
    """
    session = get_object_or_404(
        TrainingSession,
        id=session_id,
        is_active=True,
        date__gte=timezone.now().date()
    )
    
    if request.method == 'POST':
        form = FeedbackForm(request.POST)
        if form.is_valid():
            try:
                feedback = form.save(commit=False)
                feedback.session = session
                feedback.save()
                messages.success(request, 'Thank you! Your feedback has been submitted successfully.')
                return redirect('feedback:feedback_success')
            except Exception as e:
                messages.error(request, 'An error occurred while saving your feedback. Please try again.')
    else:
        form = FeedbackForm()
    return render(request, 'feedback/submit_feedback.html', {'form': form, 'session': session})

def feedback_success(request):
    """
    Render a success page after feedback submission.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page for feedback success.
    """
    return render(request, 'feedback/feedback_success.html')

@login_required
def dashboard(request):
    """
    Display the admin dashboard with summary statistics.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page for the dashboard.
    """
    if not request.user.is_staff:
        messages.error(request, 'You do not have permission to access this page.')
        return redirect('feedback:public_session_list')

    total_sessions = TrainingSession.objects.count()
    total_trainers = Trainer.objects.count()
    total_feedback = FeedbackResponse.objects.count()
    recent_sessions = TrainingSession.objects.order_by('-date')[:10]
    top_trainers = Trainer.objects.all()[:5]
    return render(request, 'feedback/dashboard.html', {
        'total_sessions': total_sessions,
        'total_trainers': total_trainers,
        'total_feedback': total_feedback,
        'recent_sessions': recent_sessions,
        'top_trainers': top_trainers,
    })

@login_required
def session_list(request):
    """
    List all training sessions for admin users with pagination.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page with paginated session list.
    """
    sessions = TrainingSession.objects.all().select_related('trainer')
    paginator = Paginator(sessions, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    return render(request, 'feedback/session_list.html', {'page_obj': page_obj})

@login_required
def create_session(request):
    """
    Create a new training session.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page for session creation or redirect on success.
    """
    if request.method == 'POST':
        form = TrainingSessionForm(request.POST)
        trainer_name = request.POST.get('trainer_name')
        if trainer_name:
            trainer, _ = Trainer.objects.get_or_create(name=trainer_name, defaults={'email': '', 'phone': '', 'specialization': '', 'is_active': True})
            post = request.POST.copy()
            post['trainer'] = trainer.id
            form = TrainingSessionForm(post)
        if form.is_valid():
            form.save()
            messages.success(request, 'Training session created successfully!')
            return redirect('feedback:session_list')
    else:
        form = TrainingSessionForm()
    return render(request, 'feedback/create_session.html', {'form': form})

@login_required
def session_detail(request, session_id):
    """
    Show details and feedback responses for a specific session.

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered HTML page with session details.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    feedback_responses = FeedbackResponse.objects.filter(session=session)
    response_count = feedback_responses.count()
    return render(request, 'feedback/session_detail.html', {
        'session': session,
        'feedback_responses': feedback_responses,
        'response_count': response_count,
    })

@login_required
def trainer_list(request):
    """
    List all trainers with pagination.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page with paginated trainer list.
    """
    trainers = Trainer.objects.all()
    paginator = Paginator(trainers, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    return render(request, 'feedback/trainer_list.html', {'page_obj': page_obj})

@login_required
def create_trainer(request):
    """
    Create a new trainer profile.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page for trainer creation or redirect on success.
    """
    if request.method == 'POST':
        form = TrainerForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Trainer profile created successfully!')
            return redirect('feedback:trainer_list')
    else:
        form = TrainerForm()
    return render(request, 'feedback/create_trainer.html', {'form': form})

@login_required
def edit_trainer(request, trainer_id):
    """
    Edit an existing trainer profile.

    Args:
        request (HttpRequest): The HTTP request object.
        trainer_id (int): The ID of the trainer.

    Returns:
        HttpResponse: Rendered HTML page for editing trainer.
    """
    trainer = get_object_or_404(Trainer, id=trainer_id)
    if request.method == 'POST':
        form = TrainerForm(request.POST, instance=trainer)
        if form.is_valid():
            form.save()
            messages.success(request, 'Trainer updated successfully!')
            return redirect('feedback:trainer_list')
    else:
        form = TrainerForm(instance=trainer)
    return render(request, 'feedback/edit_trainer.html', {'form': form, 'trainer': trainer})

@login_required
def report_detail(request, session_id):
    """
    Show the report detail page for a session (stub).

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered HTML page for report detail.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    report = None
    ai_analysis_data = None
    return render(request, 'feedback/report_detail.html', {'session': session, 'report': report, 'ai_analysis_data': ai_analysis_data})

@login_required
def generate_report(request, session_id):
    """
    Generate a report for a session (dummy implementation).

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Redirect to session detail page.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    messages.success(request, 'Report generated (dummy implementation).')
    return redirect('feedback:session_detail', session_id=session_id)

@login_required
def download_report(request, session_id):
    """
    Download a report for a session (not implemented).

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Plain text response for download.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    response = HttpResponse('Report download not implemented.', content_type='text/plain')
    response['Content-Disposition'] = f'attachment; filename="report_{session_id}.txt"'
    return response

@login_required
def download_feedback_qr(request, session_id):
    """
    Download a QR code for the feedback form of a session.

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        FileResponse: PNG image file of the QR code.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    try:
        feedback_url = request.build_absolute_uri(
            f"/session/{session.id}/feedback/"
        )
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4
        )
        qr.add_data(feedback_url)
        qr.make(fit=True)
        
        img = qr.make_image(fill_color="black", back_color="white")
        buf = BytesIO()
        img.save(buf, format='PNG')
        buf.seek(0)
        
        filename = f"feedback_session_{session.id}_qr.png"
        response = FileResponse(buf, as_attachment=True, filename=filename)
        return response
    except Exception as e:
        messages.error(request, f'Error generating QR code: {str(e)}')
        return redirect('feedback:session_detail', session_id=session.id)

@login_required
def delete_session(request, session_id):
    """
    Delete a training session after confirmation.

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered confirmation page or redirect on success.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    if request.method == 'POST':
        session.delete()
        messages.success(request, 'Training session deleted successfully!')
        return redirect('feedback:session_list')
    return render(request, 'feedback/delete_session_confirm.html', {'session': session})

@login_required
def session_report_email(request, session_id):
    """
    Generate and display a session report email (optionally send email).

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered HTML page with report email content.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    feedback_responses = FeedbackResponse.objects.filter(session=session)
    if feedback_responses.exists():
        avg_rating = round(sum([r.get_average_rating() for r in feedback_responses]) / feedback_responses.count(), 2)
    else:
        avg_rating = 0
    report_context = {
        'trainer_name': session.trainer.name,
        'session_title': session.session_title,
        'date': session.date.strftime('%b %d, %Y'),
        'location': session.location,
        'avg_rating': avg_rating,
    }
    report_text = render_to_string('feedback/session_report_email.txt', report_context)
    if request.method == 'POST':
        # Optionally, send email here
        messages.success(request, 'Report email generated!')
    return render(request, 'feedback/session_report_email.html', {
        'session': session,
        'report_text': report_text,
    })

def register(request):
    """
    Register a new user account.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered registration form or redirect on success.
    """
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect('feedback:dashboard')
    else:
        form = UserCreationForm()
    return render(request, 'registration/register.html', {'form': form})

@login_required
def feedback_summary(request):
    """
    Display a summary of feedback for all sessions, including analysis and export.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page with feedback summaries.
    """
    if not request.user.is_staff:
        messages.error(request, 'You do not have permission to access this page.')
        return redirect('feedback:public_session_list')

    try:
        sessions = TrainingSession.objects.all().select_related('trainer').prefetch_related('feedbackresponse_set')
        summary_sessions = []
        
        for session in sessions:
            feedbacks = session.feedbackresponse_set.all()
            if not feedbacks.exists():
                continue

            try:
                data = {
                    "Meet my expectation": [max(min(safe_int(getattr(f, 'rating_1', 0)), 5), 1) for f in feedbacks],
                    "Knowledge Learned": [max(min(safe_int(getattr(f, 'rating_2', 0)), 5), 1) for f in feedbacks],
                    "Content": [max(min(safe_int(getattr(f, 'rating_3', 0)), 5), 1) for f in feedbacks],
                    "Trainer Knowledgeable": [max(min(safe_int(getattr(f, 'rating_4', 0)), 5), 1) for f in feedbacks],
                    "Training Relevancy": [max(min(safe_int(getattr(f, 'rating_5', 0)), 5), 1) for f in feedbacks],
                    "Clear and understandable": [max(min(safe_int(getattr(f, 'rating_6', 0)), 5), 1) for f in feedbacks],
                    "Length Timing": [max(min(safe_int(getattr(f, 'rating_7', 0)), 5), 1) for f in feedbacks],
                    "Overall": [max(min(safe_int(getattr(f, 'rating_8', 0)), 5), 1) for f in feedbacks],
                }
                
                analyzer = FeedbackAnalyzer()
                df = analyzer.load_data_from_lists(data)
                if df.empty:
                    continue
                    
                analysis = analyzer.analyze_all_questions(df)
                summary = analyzer.generate_categorical_analysis(analysis)
                
                # Generate chart data
                chart_data = generate_chart_data(analysis)
                
                # Export to Excel
                excel_filename = f"feedback_session_{session.id}.xlsx"
                excel_path = os.path.join(settings.MEDIA_ROOT, "reports", excel_filename)
                os.makedirs(os.path.dirname(excel_path), exist_ok=True)
                
                analyzer.export_to_excel(analysis, excel_path)
                excel_url = settings.MEDIA_URL + f"reports/{excel_filename}"
                
                session.feedback_summary = summary
                session.excel_url = excel_url
                session.chart_data = json.dumps(chart_data)
                summary_sessions.append(session)
                
            except Exception as e:
                messages.warning(request, f'Error processing session {session.id}: {str(e)}')
                continue
                
        return render(request, 'feedback/feedback_summary.html', {'sessions': summary_sessions})
        
    except Exception as e:
        messages.error(request, f'Error generating feedback summary: {str(e)}')
        return redirect('feedback:dashboard')

@ensure_csrf_cookie
@login_required
def upload_feedback_image(request):
    """
    Handle feedback form image upload, process the image, and extract ratings using the AdvancedRatingDetector.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        JsonResponse: JSON response with extracted feedback, visualization, and debug info.
    """
    debug_info = {
        'request_method': request.method,
        'content_type': request.content_type,
        'has_file': 'image_file' in request.FILES,
        'session_id': request.POST.get('session'),
        'tesseract_path': pytesseract.pytesseract.tesseract_cmd,
        'tesseract_exists': os.path.isfile(pytesseract.pytesseract.tesseract_cmd),
    }

    if request.method == 'GET':
        form = FeedbackImageUploadForm()
        return render(request, 'feedback/upload_feedback_image.html', {'form': form})

    if request.method != 'POST':
        return JsonResponse({
            'success': False,
            'error': f'Method {request.method} not allowed',
            'debug_info': debug_info
        })

    tmp_path = None
    try:
        session_id = request.POST.get('session')
        if not session_id or not session_id.isdigit():
            raise ValueError('Please select a valid session.')

        session = get_object_or_404(TrainingSession, id=session_id)
        image_file = request.FILES.get('image_file')
        
        if not image_file:
            raise ValueError('No image file received.')

        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
            for chunk in image_file.chunks():
                tmp.write(chunk)
            tmp_path = tmp.name

        img = cv2.imread(tmp_path)
        if img is None:
            raise ValueError('Failed to read image file')

        detector = AdvancedRatingDetector()
        ratings, detection_debug = detector.detect_ratings(img)

        feedback_data = process_feedback_data(ratings)
        viz_img = detector.visualize_detections(img, ratings)
        viz_base64 = convert_image_to_base64(viz_img)
        
        confidence_stats = calculate_confidence_stats(ratings)

        return JsonResponse({
            'success': True,
            'feedback': feedback_data,
            'visualization': viz_base64,
            'debug_info': {
                **debug_info,
                'image_size': img.shape,
                'detection_info': detection_debug,
                'ratings_summary': confidence_stats
            }
        })

    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e),
            'traceback': traceback.format_exc(),
            'debug_info': debug_info
        })

    finally:
        if tmp_path and os.path.exists(tmp_path):
            try:
                os.unlink(tmp_path)
            except Exception:
                pass

def safe_int(val):
    try:
        return int(val)
    except (TypeError, ValueError):
        return 0

def generate_chart_data(analysis):
    chart_data = {}
    for qkey, qanalysis in analysis['question_analyses'].items():
        chart_data[qkey] = {
            'labels': ["Strongly Agree", "Agree", "Neutral", "Disagree", "Strongly Disagree"],
            'counts': [qanalysis['categorical_counts'][cat] for cat in ["Strongly Agree", "Agree", "Neutral", "Disagree", "Strongly Disagree"]],
        }
    return chart_data

def process_feedback_data(ratings):
    FEEDBACK_QUESTIONS = [
        "The training met my expectations",
        "I will be able to apply the knowledge learned",
        "The content was organized and easy to follow",
        "The trainer was knowledgeable",
        "Training was relevant to my needs",
        "Instructions were clear and understandable",
        "Length and timing of training was sufficient",
        "Overall, the session was very good"
    ]
    
    feedback_data = []
    for row in range(8):
        row_rating = next((r for r in ratings if r['row'] == row), None)
        rating = row_rating['rating'] if row_rating else 0
        confidence = row_rating['confidence'] if row_rating else 0
        question = FEEDBACK_QUESTIONS[row] if row < len(FEEDBACK_QUESTIONS) else f"Question {row + 1}"
        feedback_data.append({
            'question': question,
            'rating': rating,
            'confidence': confidence
        })
    return feedback_data

def convert_image_to_base64(image):
    _, buffer = cv2.imencode('.jpg', image)
    return base64.b64encode(buffer).decode('utf-8')

def calculate_confidence_stats(ratings):
    confidence_scores = [r['confidence'] for r in ratings]
    return {
        'total_detected': len(ratings),
        'confidence_min': min(confidence_scores) if confidence_scores else 0,
        'confidence_max': max(confidence_scores) if confidence_scores else 0,
        'confidence_avg': np.mean(confidence_scores) if confidence_scores else 0
    }