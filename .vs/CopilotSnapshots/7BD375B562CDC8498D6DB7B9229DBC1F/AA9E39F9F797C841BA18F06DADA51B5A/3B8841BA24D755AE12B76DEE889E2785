from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, FileResponse
from django.core.paginator import Paginator
from django.utils import timezone
from .models import TrainingSession, FeedbackResponse, Trainer, FeedbackReport
from .forms import FeedbackForm, TrainerForm, TrainingSessionForm, FeedbackImageUploadForm
import qrcode
from io import BytesIO
from django.template.loader import render_to_string
import pytesseract
from PIL import Image
import os
import tempfile
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth import login
import pandas as pd
import numpy as np
from .models import FeedbackResponse, TrainingSession
from django.http import FileResponse
from django.conf import settings
from .utils import FeedbackAnalyzer
import json
import cv2
import numpy as np
import shutil
from rapidfuzz import fuzz, process
import base64
from django.views.decorators.csrf import ensure_csrf_cookie

# Use system PATH for Tesseract (since tesseract is installed and available)
tesseract_path = shutil.which('tesseract')
if tesseract_path:
    pytesseract.pytesseract.tesseract_cmd = tesseract_path
else:
    # Set the full path to tesseract.exe for Windows (update this path if your tesseract.exe is elsewhere)
    pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'

# Public: List sessions for feedback (no login required)
def public_session_list(request):
    """
    Display a list of active training sessions for public feedback submission.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page with the list of sessions.
    """
    sessions = TrainingSession.objects.filter(is_active=True).select_related('trainer')
    return render(request, 'feedback/public_session_list.html', {'sessions': sessions})

# Public: Submit feedback (no login required)
def submit_feedback(request, session_id):
    """
    Allow public users to submit feedback for a specific training session.

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered HTML page for feedback form or redirect on success.
    """
    session = get_object_or_404(TrainingSession, id=session_id, is_active=True)
    if request.method == 'POST':
        form = FeedbackForm(request.POST)
        if form.is_valid():
            feedback = form.save(commit=False)
            feedback.session = session
            feedback.save()
            messages.success(request, 'Thank you! Your feedback has been submitted successfully.')
            return redirect('feedback:feedback_success')
    else:
        form = FeedbackForm()
    return render(request, 'feedback/submit_feedback.html', {'form': form, 'session': session})

def feedback_success(request):
    """
    Render a success page after feedback submission.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page for feedback success.
    """
    return render(request, 'feedback/feedback_success.html')

# Admin: Dashboard
@login_required
def dashboard(request):
    """
    Display the admin dashboard with summary statistics.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page for the dashboard.
    """
    total_sessions = TrainingSession.objects.count()
    total_trainers = Trainer.objects.count()
    total_feedback = FeedbackResponse.objects.count()
    recent_sessions = TrainingSession.objects.order_by('-date')[:10]
    top_trainers = Trainer.objects.all()[:5]
    return render(request, 'feedback/dashboard.html', {
        'total_sessions': total_sessions,
        'total_trainers': total_trainers,
        'total_feedback': total_feedback,
        'recent_sessions': recent_sessions,
        'top_trainers': top_trainers,
    })

# Admin: List, create, and edit sessions
@login_required
def session_list(request):
    """
    List all training sessions for admin users with pagination.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page with paginated session list.
    """
    sessions = TrainingSession.objects.all().select_related('trainer')
    paginator = Paginator(sessions, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    return render(request, 'feedback/session_list.html', {'page_obj': page_obj})

@login_required
def create_session(request):
    """
    Create a new training session.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page for session creation or redirect on success.
    """
    if request.method == 'POST':
        form = TrainingSessionForm(request.POST)
        trainer_name = request.POST.get('trainer_name')
        if trainer_name:
            trainer, _ = Trainer.objects.get_or_create(name=trainer_name, defaults={'email': '', 'phone': '', 'specialization': '', 'is_active': True})
            post = request.POST.copy()
            post['trainer'] = trainer.id
            form = TrainingSessionForm(post)
        if form.is_valid():
            form.save()
            messages.success(request, 'Training session created successfully!')
            return redirect('feedback:session_list')
    else:
        form = TrainingSessionForm()
    return render(request, 'feedback/create_session.html', {'form': form})

@login_required
def session_detail(request, session_id):
    """
    Show details and feedback responses for a specific session.

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered HTML page with session details.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    feedback_responses = FeedbackResponse.objects.filter(session=session)
    response_count = feedback_responses.count()
    return render(request, 'feedback/session_detail.html', {
        'session': session,
        'feedback_responses': feedback_responses,
        'response_count': response_count,
    })

# Admin: List, create, and edit trainers
@login_required
def trainer_list(request):
    """
    List all trainers with pagination.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page with paginated trainer list.
    """
    trainers = Trainer.objects.all()
    paginator = Paginator(trainers, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    return render(request, 'feedback/trainer_list.html', {'page_obj': page_obj})

@login_required
def create_trainer(request):
    """
    Create a new trainer profile.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page for trainer creation or redirect on success.
    """
    if request.method == 'POST':
        form = TrainerForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Trainer profile created successfully!')
            return redirect('feedback:trainer_list')
    else:
        form = TrainerForm()
    return render(request, 'feedback/create_trainer.html', {'form': form})

@login_required
def edit_trainer(request, trainer_id):
    """
    Edit an existing trainer profile.

    Args:
        request (HttpRequest): The HTTP request object.
        trainer_id (int): The ID of the trainer.

    Returns:
        HttpResponse: Rendered HTML page for editing trainer.
    """
    trainer = get_object_or_404(Trainer, id=trainer_id)
    if request.method == 'POST':
        form = TrainerForm(request.POST, instance=trainer)
        if form.is_valid():
            form.save()
            messages.success(request, 'Trainer updated successfully!')
            return redirect('feedback:trainer_list')
    else:
        form = TrainerForm(instance=trainer)
    return render(request, 'feedback/edit_trainer.html', {'form': form, 'trainer': trainer})

# Feedback analysis/report stubs (expand as needed)
@login_required
def report_detail(request, session_id):
    """
    Show the report detail page for a session (stub).

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered HTML page for report detail.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    report = None
    ai_analysis_data = None
    return render(request, 'feedback/report_detail.html', {'session': session, 'report': report, 'ai_analysis_data': ai_analysis_data})

@login_required
def generate_report(request, session_id):
    """
    Generate a report for a session (dummy implementation).

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Redirect to session detail page.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    messages.success(request, 'Report generated (dummy implementation).')
    return redirect('feedback:session_detail', session_id=session_id)

@login_required
def download_report(request, session_id):
    """
    Download a report for a session (not implemented).

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Plain text response for download.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    response = HttpResponse('Report download not implemented.', content_type='text/plain')
    response['Content-Disposition'] = f'attachment; filename="report_{session_id}.txt"'
    return response

@login_required
def download_feedback_qr(request, session_id):
    """
    Download a QR code for the feedback form of a session.

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        FileResponse: PNG image file of the QR code.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    feedback_url = request.build_absolute_uri(
        f"/session/{session.id}/feedback/"
    )
    qr = qrcode.QRCode(box_size=10, border=4)
    qr.add_data(feedback_url)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")
    buf = BytesIO()
    img.save(buf, format='PNG')
    buf.seek(0)
    filename = f"feedback_session_{session.id}_qr.png"
    return FileResponse(buf, as_attachment=True, filename=filename)

@login_required
def delete_session(request, session_id):
    """
    Delete a training session after confirmation.

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered confirmation page or redirect on success.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    if request.method == 'POST':
        session.delete()
        messages.success(request, 'Training session deleted successfully!')
        return redirect('feedback:session_list')
    return render(request, 'feedback/delete_session_confirm.html', {'session': session})

@login_required
def session_report_email(request, session_id):
    """
    Generate and display a session report email (optionally send email).

    Args:
        request (HttpRequest): The HTTP request object.
        session_id (int): The ID of the training session.

    Returns:
        HttpResponse: Rendered HTML page with report email content.
    """
    session = get_object_or_404(TrainingSession, id=session_id)
    feedback_responses = FeedbackResponse.objects.filter(session=session)
    if feedback_responses.exists():
        avg_rating = round(sum([r.get_average_rating() for r in feedback_responses]) / feedback_responses.count(), 2)
    else:
        avg_rating = 0
    report_context = {
        'trainer_name': session.trainer.name,
        'session_title': session.session_title,
        'date': session.date.strftime('%b %d, %Y'),
        'location': session.location,
        'avg_rating': avg_rating,
    }
    report_text = render_to_string('feedback/session_report_email.txt', report_context)
    if request.method == 'POST':
        # Optionally, send email here
        messages.success(request, 'Report email generated!')
    return render(request, 'feedback/session_report_email.html', {
        'session': session,
        'report_text': report_text,
    })

def register(request):
    """
    Register a new user account.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered registration form or redirect on success.
    """
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect('feedback:dashboard')
    else:
        form = UserCreationForm()
    return render(request, 'registration/register.html', {'form': form})

@login_required
def feedback_summary(request):
    """
    Display a summary of feedback for all sessions, including analysis and export.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        HttpResponse: Rendered HTML page with feedback summaries.
    """
    sessions = TrainingSession.objects.all().select_related('trainer')
    summary_sessions = []
    for session in sessions:
        feedbacks = FeedbackResponse.objects.filter(session=session)
        if feedbacks.exists():
            def safe_int(val):
                try:
                    return int(val)
                except Exception:
                    return 0
            data = {
                "Meet my expectation": [safe_int(getattr(f, 'rating_1', 0)) for f in feedbacks],
                "Knowledge Learned": [safe_int(getattr(f, 'rating_2', 0)) for f in feedbacks],
                "Content": [safe_int(getattr(f, 'rating_3', 0)) for f in feedbacks],
                "Trainer Knowledgeable": [safe_int(getattr(f, 'rating_4', 0)) for f in feedbacks],
                "Training Relevancy": [safe_int(getattr(f, 'rating_5', 0)) for f in feedbacks],
                "Clear and understandable": [safe_int(getattr(f, 'rating_6', 0)) for f in feedbacks],
                "Length Timing": [safe_int(getattr(f, 'rating_7', 0)) for f in feedbacks],
                "Overall": [safe_int(getattr(f, 'rating_8', 0)) for f in feedbacks],
            }
            analyzer = FeedbackAnalyzer()
            df = analyzer.load_data_from_lists(data)
            analysis = analyzer.analyze_all_questions(df)
            summary = analyzer.generate_categorical_analysis(analysis)
            chart_data = {}
            for qkey, qanalysis in analysis['question_analyses'].items():
                chart_data[qkey] = {
                    'labels': ["Strongly Agree", "Agree", "Neutral", "Disagree", "Strongly Disagree"],
                    'counts': [qanalysis['categorical_counts'][cat] for cat in ["Strongly Agree", "Agree", "Neutral", "Disagree", "Strongly Disagree"]],
                }
            excel_filename = f"feedback_session_{session.id}.xlsx"
            excel_dir = os.path.join(settings.MEDIA_ROOT, "reports")
            os.makedirs(excel_dir, exist_ok=True)
            excel_path = os.path.join(excel_dir, excel_filename)
            analyzer.export_to_excel(analysis, excel_path)
            excel_url = settings.MEDIA_URL + f"reports/{excel_filename}"
        else:
            summary = None
            excel_url = None
            chart_data = None
        session.feedback_summary = summary
        session.excel_url = excel_url
        session.chart_data = json.dumps(chart_data) if chart_data else None
        summary_sessions.append(session)
    return render(request, 'feedback/feedback_summary.html', {'sessions': summary_sessions})

@ensure_csrf_cookie
def upload_feedback_image(request):
    """
    Handle feedback form image upload, process the image, and extract ratings using the AdvancedRatingDetector.

    Args:
        request (HttpRequest): The HTTP request object.

    Returns:
        JsonResponse: JSON response with extracted feedback, visualization, and debug info.
    """
    from django.http import JsonResponse
    import traceback
    import cv2
    import numpy as np
    from PIL import Image
    import tempfile
    import os
    import base64
    from rapidfuzz import process, fuzz
    from .rating_detector import AdvancedRatingDetector

    FEEDBACK_QUESTIONS = [
        "The training met my expectations",
        "I will be able to apply the knowledge learned",
        "The content was organized and easy to follow",
        "The trainer was knowledgeable",
        "Training was relevant to my needs",
        "Instructions were clear and understandable",
        "Length and timing of training was sufficient",
        "Overall, the session was very good"
    ]

    debug_info = {
        'request_method': request.method,
        'content_type': request.content_type,
        'has_file': 'image_file' in request.FILES,
        'session_id': request.POST.get('session'),
        'tesseract_path': pytesseract.pytesseract.tesseract_cmd,
        'tesseract_exists': os.path.isfile(pytesseract.pytesseract.tesseract_cmd),
        'headers': dict(request.headers)
    }

    if request.method == 'GET':
        form = FeedbackImageUploadForm()
        return render(request, 'feedback/upload_feedback_image.html', {
            'form': form
        })

    if request.method != 'POST':
        return JsonResponse({
            'success': False,
            'error': f'Method {request.method} not allowed',
            'debug_info': debug_info
        })

    try:
        session_id = request.POST.get('session')
        if not session_id or not session_id.isdigit():
            return JsonResponse({
                'success': False,
                'error': 'Please select a valid session.',
                'debug_info': debug_info
            })

        session = TrainingSession.objects.filter(id=session_id).select_related('trainer').first()
        if not session:
            return JsonResponse({
                'success': False,
                'error': 'Session not found.',
                'debug_info': debug_info
            })

        image_file = request.FILES.get('image_file')
        tmp_path = None

        try:
            if image_file:
                with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
                    for chunk in image_file.chunks():
                        tmp.write(chunk)
                    tmp_path = tmp.name
            else:
                return JsonResponse({
                    'success': False,
                    'error': 'No image file received.',
                    'debug_info': debug_info
                })

            img = cv2.imread(tmp_path)
            if img is None:
                raise ValueError('Failed to read image file')

            detector = AdvancedRatingDetector()
            ratings, detection_debug = detector.detect_ratings(img)

            debug_info.update({
                'detection_info': detection_debug,
                'ratings_found': len(ratings)
            })

            feedback_data = []
            for row in range(8):
                row_rating = next((r for r in ratings if r['row'] == row), None)
                rating = row_rating['rating'] if row_rating else 0
                confidence = row_rating['confidence'] if row_rating else 0
                question = FEEDBACK_QUESTIONS[row] if row < len(FEEDBACK_QUESTIONS) else f"Question {row + 1}"
                feedback_data.append({
                    'question': question,
                    'rating': rating,
                    'confidence': confidence
                })
            viz_img = detector.visualize_detections(img, ratings)
            _, buffer = cv2.imencode('.jpg', viz_img)
            viz_base64 = base64.b64encode(buffer).decode('utf-8')

            confidence_scores = [r['confidence'] for r in ratings]
            avg_confidence = np.mean(confidence_scores) if confidence_scores else 0

            if os.path.exists(tmp_path):
                os.unlink(tmp_path)

            return JsonResponse({
                'success': True,
                'feedback': feedback_data,
                'visualization': viz_base64,
                'debug_info': {
                    **debug_info,
                    'image_size': img.shape,
                    'cells_found': len(feedback_data),
                    'average_confidence': avg_confidence,
                    'ratings_summary': {
                        'total_detected': len(ratings),
                        'confidence_min': min(confidence_scores) if confidence_scores else 0,
                        'confidence_max': max(confidence_scores) if confidence_scores else 0,
                        'confidence_avg': avg_confidence
                    }
                }
            })

        except Exception as e:
            if tmp_path and os.path.exists(tmp_path):
                os.unlink(tmp_path)
            raise

    except Exception as e:
        tb = traceback.format_exc()
        return JsonResponse({
            'success': False,
            'error': str(e),
            'traceback': tb,
            'debug_info': debug_info
        })